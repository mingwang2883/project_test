/*
 * copyright (c) 2004 Michael Niedermayer <michaelni@gmx.at>
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#ifndef _GET_BITS_H_
#define _GET_BITS_H_

#include <limits.h>
#include <assert.h>
#include <xutil.h>

//#define BITSTREAM_READER_LE
static int print_debug = 0;

#define OPEN_READER_NOSIZE(name, gb)          \
  unsigned int name ## _index = (gb)->index;  \
  unsigned int __attribute__((unused)) name ## _cache = 0 //; \
//  if (print_debug == 1) printf ("OPEN_READER_NOSIZE = %d\n", name ## _index);
#define OPEN_READER(name, gb)                 \
  OPEN_READER_NOSIZE(name, gb);               \
  unsigned int name ## _size_plus8 = (gb)->size_in_bits_plus8 //; \
//  if (print_debug == 1) printf ("OPEN_READER = %d\n", name ## _size_plus8);

#define CLOSE_READER(name, gb) (gb)->index = name ## _index

#define SKIP_COUNTER(name, gb, num) \
  name ## _index = MIN(name ## _size_plus8, name ## _index + (num));

#define LAST_SKIP_BITS(name, gb, num) SKIP_COUNTER(name, gb, num)

#define UPDATE_CACHE_LE(name, gb) name ## _cache = \
  (* (uint32_t *) ((gb)->buffer + (name ## _index >> 3))) >> (name ## _index & 7)

#define UPDATE_CACHE_BE(name, gb) name ## _cache = \
  ntohl(*(uint32_t *) ((gb)->buffer + (name ## _index >> 3))) << (name ## _index & 7); //\
//  if (print_debug == 1) {printf ("UPDATE_CACHE_BE = %d\n", name ## _cache); \
  printf ("name ## _index  = %d\n", name ## _index );  printf ("(gb)->buffer  = %d\n", (gb)->buffer ); }

#ifdef BITSTREAM_READER_LE
# define UPDATE_CACHE(name, gb) UPDATE_CACHE_LE(name, gb) 
#else
# define UPDATE_CACHE(name, gb) UPDATE_CACHE_BE(name, gb) 
#endif

#define NEG_USR32(a,s) (((uint32_t)(a))>>(32-(s)))

#define SHOW_UBITS_LE(name, gb, num) zero_extend(name ## _cache, num)
#define SHOW_UBITS_BE(name, gb, num) NEG_USR32(name ## _cache, num)

#ifdef BITSTREAM_READER_LE
# define SHOW_UBITS(name, gb, num) SHOW_UBITS_LE(name, gb, num)
#else
# define SHOW_UBITS(name, gb, num) SHOW_UBITS_BE(name, gb, num)
#endif

#define GET_CACHE(name, gb) ((uint32_t) name ## _cache);

const uint8_t ff_golomb_vlc_len[512]={
  19,17,15,15,13,13,13,13,11,11,11,11,11,11,11,11,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
  3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};

const uint8_t ff_ue_golomb_vlc_code[512]={
  32,32,32,32,32,32,32,32,31,32,32,32,32,32,32,32,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
  7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,10,10,10,11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,14,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

const int8_t ff_se_golomb_vlc_code[512]={
  17, 17, 17, 17, 17, 17, 17, 17, 16, 17, 17, 17, 17, 17, 17, 17,  8, -8,  9, -9, 10,-10, 11,-11, 12,-12, 13,-13, 14,-14, 15,-15,
  4,  4,  4,  4, -4, -4, -4, -4,  5,  5,  5,  5, -5, -5, -5, -5,  6,  6,  6,  6, -6, -6, -6, -6,  7,  7,  7,  7, -7, -7, -7, -7,
  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
};

namespace xutil {

#ifdef BITSTREAM_READER_LE
static inline unsigned zero_extend(unsigned val, unsigned bits)
{
  return (val << ((8 * sizeof(int)) - bits)) >> ((8 * sizeof(int)) - bits);
}
#endif

struct GetBitContext {
  const uint8_t *buffer, *buffer_end;
  int index;
  int size_in_bits;
  int size_in_bits_plus8;
};

static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,
                                int bit_size)
{
  int buffer_size;
  int ret = 0;

  if (bit_size >= INT_MAX - 7 || bit_size < 0 || !buffer) {
    bit_size    = 0;
    buffer      = NULL; 
    ret         = -1;
  }

  buffer_size = (bit_size + 7) >> 3;

  s->buffer             = buffer;
  s->size_in_bits       = bit_size;
  s->size_in_bits_plus8 = bit_size + 8;
  s->buffer_end         = buffer + buffer_size;
  s->index              = 0;

  return ret;
}

static inline void skip_bits(GetBitContext *s, int n)
{
  OPEN_READER(re, s);
  LAST_SKIP_BITS(re, s, n);
  CLOSE_READER(re, s);
}

static inline void skip_bits1(GetBitContext *s)
{
  skip_bits(s, 1);
}

static inline unsigned int get_bits1(GetBitContext *s)
{
  unsigned int index = s->index;
  uint8_t result     = s->buffer[index >> 3];
#ifdef BITSTREAM_READER_LE
  result >>= index & 7;
  result  &= 1;
#else
  result <<= index & 7;
  result >>= 8 - 1;
#endif
  if (s->index < s->size_in_bits_plus8)
    index++;
  s->index = index;

  return result;
}


/**
 * Read 1-25 bits.
 */
static inline unsigned int get_bits(GetBitContext *s, int n)
{
  register int tmp;
  OPEN_READER(re, s);
  assert(n>0 && n<=25);
  UPDATE_CACHE(re, s);
  tmp = SHOW_UBITS(re, s, n);
  LAST_SKIP_BITS(re, s, n);
  CLOSE_READER(re, s);
  return tmp;
}

static inline int get_ue_golomb_31(GetBitContext *gb) 
{
  unsigned int buf;

  print_debug = 1;
  OPEN_READER(re, gb);
  UPDATE_CACHE(re, gb);
  buf = GET_CACHE(re, gb);
//  printf("buf 111: %d\n",buf);

  buf >>= 32 - 9;
  LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);
  CLOSE_READER(re, gb);
  print_debug =  0;

//  printf("buf : %d\n",buf);
  return ff_ue_golomb_vlc_code[buf];
}

static int av_log2(unsigned v) { int r = 0; while (v >>= 1) r++; return r; }

static inline int get_ue_golomb(GetBitContext *gb)
{           
  unsigned int buf;

  OPEN_READER(re, gb);
  UPDATE_CACHE(re, gb);
  buf = GET_CACHE(re, gb);

  if (buf >= (1 << 27)) {
    buf >>= 32 - 9;
    LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);
    CLOSE_READER(re, gb);

    return ff_ue_golomb_vlc_code[buf];
  } else {
    int log = 2 * av_log2(buf) - 31;
    LAST_SKIP_BITS(re, gb, 32 - log);
    CLOSE_READER(re, gb);   
    buf >>= log;
    buf--;

    return buf;
  }
}

static inline int get_se_golomb(GetBitContext *gb) 
{   
  unsigned int buf;

  OPEN_READER(re, gb);
  UPDATE_CACHE(re, gb);
  buf = GET_CACHE(re, gb); 

  if (buf >= (1 << 27)) {
    buf >>= 32 - 9;
    LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);
    CLOSE_READER(re, gb);

    return ff_se_golomb_vlc_code[buf];
  } else {
    int log = av_log2(buf);
    LAST_SKIP_BITS(re, gb, 31 - log);
    UPDATE_CACHE(re, gb);       
    buf = GET_CACHE(re, gb);    

    buf >>= log; 

    LAST_SKIP_BITS(re, gb, 32 - log);
    CLOSE_READER(re, gb);

    if (buf & 1)
      buf = -(buf >> 1);
    else
      buf = (buf >> 1);

    return buf;
  }
}

}

#endif /* end of _GET_BITS_H_ */
